{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "85f920be-b9a3-4688-bdb0-a3372f48f790",
   "metadata": {},
   "outputs": [],
   "source": [
    "# app.py\n",
    "import streamlit as st\n",
    "import datetime as dt\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import yfinance as yf\n",
    "from scipy.stats import norm\n",
    "from pypfopt import EfficientFrontier, risk_models, expected_returns\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import LSTM, Dense, Dropout, Input\n",
    "from tensorflow.keras.callbacks import EarlyStopping\n",
    "from sklearn.preprocessing import MinMaxScaler\n",
    "import plotly.graph_objects as go\n",
    "from plotly.subplots import make_subplots\n",
    "\n",
    "st.set_page_config(layout=\"wide\")\n",
    "\n",
    "st.title(\"ðŸ“Š Portfolio Analysis & Prediction Dashboard\")\n",
    "\n",
    "# --- Ticker Input ---\n",
    "ticker_input = st.text_input(\"Enter Tickers (comma-separated)\", value=\"AAPL, MSFT, TSLA\")\n",
    "\n",
    "if ticker_input:\n",
    "    tickers = [t.strip().upper() for t in ticker_input.split(',') if t.strip()]\n",
    "    units = {}\n",
    "\n",
    "    st.subheader(\"ðŸ“¦ Number of Shares per Ticker\")\n",
    "    cols = st.columns(len(tickers))\n",
    "    for i, t in enumerate(tickers):\n",
    "        units[t] = cols[i].number_input(f\"{t}\", min_value=0, value=1, step=1)\n",
    "\n",
    "    if st.button(\"ðŸ“ˆ Run Analysis\"):\n",
    "        with st.spinner(\"Fetching data and computing portfolio...\"):\n",
    "\n",
    "            # --- Data Download ---\n",
    "            start = dt.datetime(2023, 10, 1)\n",
    "            end = dt.datetime.now()\n",
    "            units_arr = np.array([units[t] for t in tickers])\n",
    "            df = yf.download(['^GSPC'] + tickers, start, end, auto_adjust=True)\n",
    "            Close = df['Close'][['^GSPC'] + tickers]\n",
    "            log_returns = np.log(Close / Close.shift(1)).dropna()\n",
    "\n",
    "            def calc_beta(df):\n",
    "                m = df.iloc[:, 0].values\n",
    "                return pd.Series([\n",
    "                    np.cov(df.iloc[:, i].values, m)[0, 1] / np.var(m) if np.var(m) > 0 else np.nan\n",
    "                    for i in range(1, df.shape[1])\n",
    "                ], index=df.columns[1:], name=\"Beta\")\n",
    "\n",
    "            beta = calc_beta(log_returns)\n",
    "            stocklist = yf.download(tickers, start, end, auto_adjust=True)\n",
    "            prices = stocklist['Close'].iloc[-1][tickers].values\n",
    "            value = units_arr * prices\n",
    "            weights = value / value.sum()\n",
    "            beta = round(beta, 2)\n",
    "\n",
    "            portfolio = pd.DataFrame({\n",
    "                'Price': prices,\n",
    "                'Units': units_arr,\n",
    "                'Current Value': value,\n",
    "                'Weights': weights.round(2),\n",
    "                'Beta': beta.values,\n",
    "                'Weighted Beta': weights * beta.values\n",
    "            }, index=tickers)\n",
    "\n",
    "            sp500 = yf.download('^GSPC', start, end)\n",
    "            sp500_price = sp500.Close.iloc[-1]\n",
    "            portfolio['SP500 Weighted Delta (point)'] = round(portfolio['Beta'] * portfolio['Price'] / sp500_price * portfolio['Units'], 2)\n",
    "            portfolio['SP500 Weighted Delta (1%)'] = round(portfolio['Beta'] * portfolio['Price'] * portfolio['Units'] * 0.01, 2)\n",
    "\n",
    "            totals = portfolio[['Current Value', 'SP500 Weighted Delta (point)', 'SP500 Weighted Delta (1%)']].sum()\n",
    "            portfolio.loc['Total'] = ['', '', *totals, '', '']\n",
    "\n",
    "            st.dataframe(portfolio)\n",
    "\n",
    "            # --- Timeline Plot ---\n",
    "            st.subheader(\"ðŸ“ˆ Portfolio vs S&P 500\")\n",
    "            close_prices = stocklist['Close'][tickers]\n",
    "            portfolio_ts = (close_prices * units_arr).sum(axis=1)\n",
    "\n",
    "            fig1 = make_subplots(specs=[[{\"secondary_y\": True}]])\n",
    "            fig1.add_trace(go.Scatter(x=portfolio_ts.index, y=portfolio_ts, name=\"Portfolio\"), secondary_y=False)\n",
    "            fig1.add_trace(go.Scatter(x=sp500.index, y=sp500['Close'], name=\"S&P 500\"), secondary_y=True)\n",
    "            fig1.update_layout(title=\"Portfolio Value vs S&P 500\", template='plotly_white')\n",
    "            st.plotly_chart(fig1, use_container_width=True)\n",
    "\n",
    "            # --- VaR & CVaR ---\n",
    "            st.subheader(\"ðŸ“‰ VaR and CVaR\")\n",
    "            log_tfsa_returns = np.log(portfolio_ts/portfolio_ts.shift(1)).dropna()\n",
    "            VaR = np.percentile(log_tfsa_returns, 5)\n",
    "            CVaR = log_tfsa_returns[log_tfsa_returns <= VaR].mean()\n",
    "            VaR_pct, CVaR_pct = VaR * 100, CVaR * 100\n",
    "\n",
    "            fig2 = go.Figure()\n",
    "            fig2.add_trace(go.Histogram(x=log_tfsa_returns * 100, nbinsx=500))\n",
    "            fig2.add_vline(x=VaR_pct, line=dict(color=\"red\", dash=\"dash\"))\n",
    "            fig2.add_vline(x=CVaR_pct, line=dict(color=\"darkred\", dash=\"dot\"))\n",
    "            st.plotly_chart(fig2, use_container_width=True)\n",
    "\n",
    "            # --- Sharpe Ratio ---\n",
    "            st.subheader(\"âš–ï¸ Sharpe Ratio\")\n",
    "            volatility = log_tfsa_returns.rolling(60).std()*np.sqrt(60)\n",
    "            sp500_log_returns = np.log(Close['^GSPC'] / Close['^GSPC'].shift(1)).dropna()\n",
    "            total_return = np.exp(sp500_log_returns.sum()) - 1\n",
    "            num_years = (Close.index[-1] - Close.index[0]).days / 365\n",
    "            annual_sp500_return = (1 + total_return)**(1/num_years) - 1\n",
    "            Rf = annual_sp500_return / 252\n",
    "            sharpe_ratio = (log_tfsa_returns.rolling(60).mean() - Rf) * 60 / volatility\n",
    "\n",
    "            fig3 = go.Figure()\n",
    "            fig3.add_trace(go.Scatter(x=sharpe_ratio.index, y=sharpe_ratio, name=\"Sharpe Ratio\"))\n",
    "            fig3.update_layout(title=\"Portfolio Sharpe Ratio\", template=\"plotly_white\")\n",
    "            st.plotly_chart(fig3, use_container_width=True)\n",
    "\n",
    "            # --- Portfolio Optimization ---\n",
    "            st.subheader(\"ðŸ”§ Portfolio Optimization\")\n",
    "            mu = expected_returns.mean_historical_return(stocklist['Close'][tickers])\n",
    "            S = risk_models.sample_cov(stocklist['Close'][tickers])\n",
    "            ef = EfficientFrontier(mu, S)\n",
    "            optimal_weights = ef.max_sharpe()\n",
    "            cleaned_weights = ef.clean_weights()\n",
    "\n",
    "            comparison_df = pd.DataFrame({\n",
    "                'Current Weight': weights,\n",
    "                'Optimal Weight': pd.Series(cleaned_weights)\n",
    "            })\n",
    "\n",
    "            fig5 = go.Figure()\n",
    "            fig5.add_trace(go.Bar(x=comparison_df.index, y=comparison_df['Current Weight'], name=\"Current\"))\n",
    "            fig5.add_trace(go.Bar(x=comparison_df.index, y=comparison_df['Optimal Weight'], name=\"Optimal\"))\n",
    "            fig5.update_layout(barmode=\"group\", title=\"Weight Comparison\", template=\"plotly_white\")\n",
    "            st.plotly_chart(fig5, use_container_width=True)\n",
    "\n",
    "            # --- Monte Carlo Simulation ---\n",
    "            st.subheader(\"ðŸŽ² Monte Carlo Simulation\")\n",
    "            daily_std = log_tfsa_returns.std()\n",
    "            u = log_tfsa_returns.mean()\n",
    "            drift = u - 0.5 * log_tfsa_returns.var()\n",
    "            t_intervals = 1000\n",
    "            iterations = 250\n",
    "            daily_returns = np.exp(drift + daily_std * norm.ppf(np.random.rand(t_intervals, iterations)))\n",
    "            s0 = portfolio_ts.iloc[-1]\n",
    "            price_list = np.zeros_like(daily_returns)\n",
    "            price_list[0] = s0\n",
    "            for t in range(1, t_intervals):\n",
    "                price_list[t] = price_list[t-1] * daily_returns[t]\n",
    "\n",
    "            fig4 = go.Figure()\n",
    "            for i in range(iterations):\n",
    "                fig4.add_trace(go.Scatter(x=np.arange(t_intervals), y=price_list[:, i], line=dict(width=1), showlegend=False))\n",
    "            fig4.add_trace(go.Scatter(x=np.arange(t_intervals), y=price_list.mean(axis=1), name=\"Average Path\", line=dict(color='black', dash='dash')))\n",
    "            fig4.update_layout(title=\"Monte Carlo Simulation\", template=\"plotly_white\")\n",
    "            st.plotly_chart(fig4, use_container_width=True)\n",
    "\n",
    "            # --- LSTM Forecast ---\n",
    "            st.subheader(\"ðŸ¤– LSTM Forecast\")\n",
    "            monthly_prices = stocklist.Close.resample('ME').last()\n",
    "            monthly_returns = monthly_prices.pct_change().dropna()\n",
    "            weights_arr = np.array([weights[i] if i in monthly_returns.columns else 0 for i in tickers])\n",
    "            portfolio_monthly_returns = monthly_returns.dot(weights_arr)\n",
    "\n",
    "            def create_sequences(data, seq_length=12):\n",
    "                X, y = [], []\n",
    "                for i in range(len(data) - seq_length):\n",
    "                    X.append(data[i:i+seq_length])\n",
    "                    y.append(data[i+seq_length])\n",
    "                return np.array(X), np.array(y)\n",
    "\n",
    "            seq_length = 12\n",
    "            returns_values = portfolio_monthly_returns.values\n",
    "            X, y = create_sequences(returns_values)\n",
    "            scaler_X, scaler_y = MinMaxScaler(), MinMaxScaler()\n",
    "            X_scaled = scaler_X.fit_transform(X.reshape(-1, 1)).reshape(X.shape)\n",
    "            y_scaled = scaler_y.fit_transform(y.reshape(-1, 1))\n",
    "            split = int(0.8 * len(X_scaled))\n",
    "            X_train, X_val = X_scaled[:split], X_scaled[split:]\n",
    "            y_train, y_val = y_scaled[:split], y_scaled[split:]\n",
    "\n",
    "            model = Sequential([\n",
    "                Input(shape=(seq_length, 1)),\n",
    "                LSTM(64, return_sequences=True),\n",
    "                Dropout(0.2),\n",
    "                LSTM(32),\n",
    "                Dense(1)\n",
    "            ])\n",
    "            model.compile(optimizer='adam', loss='mse')\n",
    "            model.fit(X_train, y_train, validation_data=(X_val, y_val),\n",
    "                      epochs=100, batch_size=4, callbacks=[EarlyStopping(patience=5, restore_best_weights=True)], verbose=0)\n",
    "\n",
    "            last_seq = returns_values[-seq_length:]\n",
    "            last_seq_scaled = scaler_X.transform(last_seq.reshape(-1, 1)).reshape(1, seq_length, 1)\n",
    "            pred_scaled = model.predict(last_seq_scaled)\n",
    "            predicted_return = scaler_y.inverse_transform(pred_scaled)\n",
    "\n",
    "            st.success(f\"ðŸ“… Predicted Return Next Month: **{predicted_return[0][0]:.2%}**\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
